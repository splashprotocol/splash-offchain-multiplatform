use bloom_offchain::execution_engine::liquidity_book::types::Lovelace;
use cml_chain::address::{Address, BaseAddress, EnterpriseAddress};
use cml_chain::assets::MultiAsset;
use cml_chain::certs::StakeCredential;
use cml_chain::plutus::PlutusData;
use cml_chain::transaction::{ConwayFormatTxOut, TransactionOutput};
use cml_chain::{Coin, Value};
use cml_crypto::{Ed25519KeyHash, ScriptHash};

use spectrum_cardano_lib::asset_bundle::SafeAssetBundleOps;
use spectrum_cardano_lib::{NetworkId, TaggedAmount, TaggedAssetClass, Token};
use spectrum_offchain::domain::Has;
use spectrum_offchain::ledger::IntoLedger;

use crate::data::order::Quote;
use crate::data::pool::{Lq, Rx, Ry};
use crate::deployment::DeployedValidatorErased;

/// `MultipleOutputs` represents a collection of results generated by an order execution process,
/// capturing both primary and secondary results of the operation.
///
/// Fields:
/// - `action_result_output`: The main result of the action, which should be placed at the specified
///   `order_out_idx` position within the outputs of the final transaction.
/// - `sub_action_utxos`: A vector of additional results produced by the pipeline. These outputs do
///   not require direct validation by the order contract but are part of the overall result.
///   For instance, in DAO pipeline scenarios such as a treasury withdrawal, the primary request
///   order validates only the correctness of fee subtraction. However, the pipeline generates two
///   outputs: one UTXO for the requesterâ€™s address and another for the treasury withdrawal.
///   The latter is validated by the DAO v1 contract, rather than directly by the order contract.
pub struct MultipleOutputs<T> {
    pub action_result_output: T,
    pub sub_action_utxos: Vec<T>,
}

// Operation could produce more than one output
pub enum OperationResultOutputs<T> {
    SingleOutput(T),
    MultipleOutputs(MultipleOutputs<T>),
}

impl<T> OperationResultOutputs<T> {
    pub fn multiple(action_result: T, additional_outputs: Vec<T>) -> Self {
        OperationResultOutputs::MultipleOutputs(MultipleOutputs {
            action_result_output: action_result,
            sub_action_utxos: additional_outputs,
        })
    }
}

pub struct OperationResultContext {
    pub pool_input_idx: u64,
    pub order_input_idx: u64,
}

pub struct ContexBasedRedeemerCreator(Box<dyn FnOnce(OperationResultContext) -> PlutusData>);

impl ContexBasedRedeemerCreator {
    pub fn compute(self, pool_input_idx: u64, order_input_idx: u64) -> PlutusData {
        self.0(OperationResultContext {
            pool_input_idx,
            order_input_idx,
        })
    }

    pub fn create(f: impl FnOnce(OperationResultContext) -> PlutusData + 'static) -> ContexBasedRedeemerCreator {
        ContexBasedRedeemerCreator(Box::new(f))
    }
}

/// `OperationResultBlueprint` represents the outcome of an order execution, containing essential
/// details for processing the result, including results, validation scripts, and optional fees.
///
/// Fields:
/// - `outputs`: A batch of results generated by the order execution. Unlike simple deposit or
///   redeem operations, more complex orders (e.g., DAO or royalty pipelines) may produce multiple
///   outputs as part of the transaction result.
/// - `witness_script`: An optional witness script required for specific cases, such as the pool
///   contract's delegation validation logic. When provided, this contains a `DeployedValidatorErased`
///   instance and a closure that generates the necessary Redeemer directly represented by
///   `PlutusData`.
/// - `order_script_validator`: The reference UTXO holding the order script, used to validate the
///   execution of the order.
/// - `strict_fee`: An optional field providing a temporary solution to account for situations where
///   CML may produce incorrect `min_fee` values.
pub struct OperationResultBlueprint<T> {
    pub outputs: OperationResultOutputs<T>,
    pub witness_script: Option<(DeployedValidatorErased, ContexBasedRedeemerCreator)>,
    pub order_script_validator: DeployedValidatorErased,
    pub strict_fee: Option<Coin>,
}

impl<T> OperationResultBlueprint<T> {
    pub fn single_output(output: T, validator: DeployedValidatorErased) -> OperationResultBlueprint<T> {
        Self {
            outputs: OperationResultOutputs::SingleOutput(output),
            witness_script: None,
            order_script_validator: validator,
            strict_fee: None,
        }
    }
}

#[derive(Debug, Clone)]
pub struct SwapOutput {
    pub quote_asset: TaggedAssetClass<Quote>,
    pub quote_amount: TaggedAmount<Quote>,
    pub ada_residue: Coin,
    pub redeemer_pkh: Ed25519KeyHash,
    pub redeemer_stake_pkh: Option<Ed25519KeyHash>,
}

impl<Ctx> IntoLedger<TransactionOutput, Ctx> for SwapOutput
where
    Ctx: Has<NetworkId>,
{
    fn into_ledger(self, ctx: Ctx) -> TransactionOutput {
        let addr = if let Some(stake_pkh) = self.redeemer_stake_pkh {
            BaseAddress::new(
                ctx.get().into(),
                StakeCredential::new_pub_key(self.redeemer_pkh),
                StakeCredential::new_pub_key(stake_pkh),
            )
            .to_address()
        } else {
            EnterpriseAddress::new(ctx.get().into(), StakeCredential::new_pub_key(self.redeemer_pkh))
                .to_address()
        };

        let mut ma = MultiAsset::new();

        let ada_from_quote = if self.quote_asset.is_native() {
            self.quote_amount.untag()
        } else {
            let Token(policy, name) = self.quote_asset.untag().into_token().unwrap();
            ma.safe_set(policy, name.into(), self.quote_amount.untag());
            0
        };

        let ada = self.ada_residue + ada_from_quote;

        TransactionOutput::new_conway_format_tx_out(ConwayFormatTxOut {
            address: addr,
            amount: Value::new(ada, ma),
            datum_option: None,
            script_reference: None,
            encodings: None,
        })
    }
}

#[derive(Debug, Clone)]
pub struct DepositOutput {
    pub token_x_asset: TaggedAssetClass<Rx>,
    pub token_x_charge_amount: TaggedAmount<Rx>,
    pub token_y_asset: TaggedAssetClass<Ry>,
    pub token_y_charge_amount: TaggedAmount<Ry>,
    pub token_lq_asset: TaggedAssetClass<Lq>,
    pub token_lq_amount: TaggedAmount<Lq>,
    pub ada_residue: Coin,
    pub redeemer_pkh: Ed25519KeyHash,
    pub redeemer_stake_pkh: Option<Ed25519KeyHash>,
}

impl<Ctx> IntoLedger<TransactionOutput, Ctx> for DepositOutput
where
    Ctx: Has<NetworkId>,
{
    fn into_ledger(self, ctx: Ctx) -> TransactionOutput {
        let addr = if let Some(stake_pkh) = self.redeemer_stake_pkh {
            BaseAddress::new(
                ctx.get().into(),
                StakeCredential::new_pub_key(self.redeemer_pkh),
                StakeCredential::new_pub_key(stake_pkh),
            )
            .to_address()
        } else {
            EnterpriseAddress::new(ctx.get().into(), StakeCredential::new_pub_key(self.redeemer_pkh))
                .to_address()
        };

        let mut ma = MultiAsset::new();

        let ada_from_charge_pair = match (self.token_x_asset.is_native(), self.token_y_asset.is_native()) {
            (true, false) => {
                let Token(policy, name) = self.token_y_asset.untag().into_token().unwrap();
                ma.safe_set(policy, name.into(), self.token_y_charge_amount.untag());
                self.token_x_charge_amount.untag()
            }
            (false, true) => {
                let Token(policy, name) = self.token_x_asset.untag().into_token().unwrap();
                ma.safe_set(policy, name.into(), self.token_x_charge_amount.untag());
                self.token_y_charge_amount.untag()
            }
            (false, false) => {
                let Token(policy_x, name_x) = self.token_x_asset.untag().into_token().unwrap();
                ma.safe_set(policy_x, name_x.into(), self.token_x_charge_amount.untag());
                let Token(policy_y, name_y) = self.token_y_asset.untag().into_token().unwrap();
                ma.safe_set(policy_y, name_y.into(), self.token_y_charge_amount.untag());
                0
            }
            // todo: basically this is unreachable point. Throw error?
            (true, true) => self.token_x_charge_amount.untag() + self.token_y_charge_amount.untag(),
        };

        let ada = self.ada_residue + ada_from_charge_pair;

        let Token(policy_lq, name_lq) = self.token_lq_asset.untag().into_token().unwrap();

        ma.set(policy_lq, name_lq.into(), self.token_lq_amount.untag());

        TransactionOutput::new_conway_format_tx_out(ConwayFormatTxOut {
            address: addr,
            amount: Value::new(ada, ma),
            datum_option: None,
            script_reference: None,
            encodings: None,
        })
    }
}

#[derive(Debug, Clone)]
pub struct RedeemOutput {
    pub token_x_asset: TaggedAssetClass<Rx>,
    pub token_x_amount: TaggedAmount<Rx>,
    pub token_y_asset: TaggedAssetClass<Ry>,
    pub token_y_amount: TaggedAmount<Ry>,
    pub ada_residue: Coin,
    pub redeemer_pkh: Ed25519KeyHash,
    pub redeemer_stake_pkh: Option<Ed25519KeyHash>,
}

impl<Ctx> IntoLedger<TransactionOutput, Ctx> for RedeemOutput
where
    Ctx: Has<NetworkId>,
{
    fn into_ledger(self, ctx: Ctx) -> TransactionOutput {
        let addr = if let Some(stake_pkh) = self.redeemer_stake_pkh {
            BaseAddress::new(
                ctx.get().into(),
                StakeCredential::new_pub_key(self.redeemer_pkh),
                StakeCredential::new_pub_key(stake_pkh),
            )
            .to_address()
        } else {
            EnterpriseAddress::new(ctx.get().into(), StakeCredential::new_pub_key(self.redeemer_pkh))
                .to_address()
        };

        let mut ma = MultiAsset::new();

        let ada_from_charge_pair = match (self.token_x_asset.is_native(), self.token_y_asset.is_native()) {
            (true, false) => {
                let Token(policy, name) = self.token_y_asset.untag().into_token().unwrap();
                ma.safe_set(policy, name.into(), self.token_y_amount.untag());
                self.token_x_amount.untag()
            }
            (false, true) => {
                let Token(policy, name) = self.token_x_asset.untag().into_token().unwrap();
                ma.safe_set(policy, name.into(), self.token_x_amount.untag());
                self.token_y_amount.untag()
            }
            (false, false) => {
                let Token(policy_x, name_x) = self.token_x_asset.untag().into_token().unwrap();
                ma.safe_set(policy_x, name_x.into(), self.token_x_amount.untag());
                let Token(policy_y, name_y) = self.token_y_asset.untag().into_token().unwrap();
                ma.safe_set(policy_y, name_y.into(), self.token_y_amount.untag());
                0
            }
            // todo: basically this is unreachable point. Throw error?
            (true, true) => self.token_x_amount.untag() + self.token_y_amount.untag(),
        };

        let ada = self.ada_residue + ada_from_charge_pair;

        TransactionOutput::new_conway_format_tx_out(ConwayFormatTxOut {
            address: addr,
            amount: Value::new(ada, ma),
            datum_option: None,
            script_reference: None,
            encodings: None,
        })
    }
}

#[derive(Debug, Clone)]
pub struct RoyaltyWithdrawOutput {
    pub token_x_asset: TaggedAssetClass<Rx>,
    pub token_x_amount: TaggedAmount<Rx>,
    pub token_y_asset: TaggedAssetClass<Ry>,
    pub token_y_amount: TaggedAmount<Ry>,
    pub ada_residue: Coin,
    pub redeemer_pkh: Ed25519KeyHash,
}

impl<Ctx> IntoLedger<TransactionOutput, Ctx> for RoyaltyWithdrawOutput
where
    Ctx: Has<NetworkId>,
{
    fn into_ledger(self, ctx: Ctx) -> TransactionOutput {
        let addr = EnterpriseAddress::new(ctx.get().into(), StakeCredential::new_pub_key(self.redeemer_pkh))
            .to_address();

        let mut ma = MultiAsset::new();

        let ada_from_charge_pair = match (self.token_x_asset.is_native(), self.token_y_asset.is_native()) {
            (true, false) => {
                let Token(policy, name) = self.token_y_asset.untag().into_token().unwrap();
                ma.safe_set(policy, name.into(), self.token_y_amount.untag());
                self.token_x_amount.untag()
            }
            (false, true) => {
                let Token(policy, name) = self.token_x_asset.untag().into_token().unwrap();
                ma.safe_set(policy, name.into(), self.token_x_amount.untag());
                self.token_y_amount.untag()
            }
            (false, false) => {
                let Token(policy_x, name_x) = self.token_x_asset.untag().into_token().unwrap();
                ma.safe_set(policy_x, name_x.into(), self.token_x_amount.untag());
                let Token(policy_y, name_y) = self.token_y_asset.untag().into_token().unwrap();
                ma.safe_set(policy_y, name_y.into(), self.token_y_amount.untag());
                0
            }
            // todo: basically this is unreachable point. Throw error?
            (true, true) => self.token_x_amount.untag() + self.token_y_amount.untag(),
        };

        let ada = self.ada_residue + ada_from_charge_pair;

        TransactionOutput::new_conway_format_tx_out(ConwayFormatTxOut {
            address: addr,
            amount: Value::new(ada, ma),
            datum_option: None,
            script_reference: None,
            encodings: None,
        })
    }
}

#[derive(Debug, Clone)]
pub enum DaoActionResult {
    RequestorOutput(DaoRequestorOutput),
    TreasuryWithdraw(TreasuryWithdrawOutput),
}

impl<Ctx> IntoLedger<TransactionOutput, Ctx> for DaoActionResult
where
    Ctx: Has<NetworkId>,
{
    fn into_ledger(self, ctx: Ctx) -> TransactionOutput {
        match self {
            DaoActionResult::RequestorOutput(requestor_output) => requestor_output.into_ledger(ctx),
            DaoActionResult::TreasuryWithdraw(withdraw_output) => withdraw_output.into_ledger(ctx),
        }
    }
}

#[derive(Debug, Clone)]
pub struct DaoRequestorOutput {
    pub lovelace_qty: Lovelace,
    pub requestor_address: Address,
}

impl<Ctx> IntoLedger<TransactionOutput, Ctx> for DaoRequestorOutput
where
    Ctx: Has<NetworkId>,
{
    fn into_ledger(self, ctx: Ctx) -> TransactionOutput {
        TransactionOutput::new_conway_format_tx_out(ConwayFormatTxOut {
            address: self.requestor_address,
            amount: Value::from(self.lovelace_qty),
            datum_option: None,
            script_reference: None,
            encodings: None,
        })
    }
}

#[derive(Debug, Clone)]
pub struct TreasuryWithdrawOutput {
    pub token_x_asset: TaggedAssetClass<Rx>,
    pub token_x_amount: TaggedAmount<Rx>,
    pub token_y_asset: TaggedAssetClass<Ry>,
    pub token_y_amount: TaggedAmount<Ry>,
    pub ada_residue: Coin,
    pub treasury_script_hash: ScriptHash,
}

impl<Ctx> IntoLedger<TransactionOutput, Ctx> for TreasuryWithdrawOutput
where
    Ctx: Has<NetworkId>,
{
    fn into_ledger(self, ctx: Ctx) -> TransactionOutput {
        let addr = EnterpriseAddress::new(
            ctx.get().into(),
            StakeCredential::new_script(self.treasury_script_hash),
        )
        .to_address();

        let mut ma = MultiAsset::new();

        let ada_from_charge_pair = match (self.token_x_asset.is_native(), self.token_y_asset.is_native()) {
            (true, false) => {
                let Token(policy, name) = self.token_y_asset.untag().into_token().unwrap();
                ma.safe_set(policy, name.into(), self.token_y_amount.untag());
                self.token_x_amount.untag()
            }
            (false, true) => {
                let Token(policy, name) = self.token_x_asset.untag().into_token().unwrap();
                ma.safe_set(policy, name.into(), self.token_x_amount.untag());
                self.token_y_amount.untag()
            }
            (false, false) => {
                let Token(policy_x, name_x) = self.token_x_asset.untag().into_token().unwrap();
                ma.safe_set(policy_x, name_x.into(), self.token_x_amount.untag());
                let Token(policy_y, name_y) = self.token_y_asset.untag().into_token().unwrap();
                ma.safe_set(policy_y, name_y.into(), self.token_y_amount.untag());
                0
            }
            // todo: basically this is unreachable point. Throw error?
            (true, true) => self.token_x_amount.untag() + self.token_y_amount.untag(),
        };

        let ada = self.ada_residue + ada_from_charge_pair;

        TransactionOutput::new_conway_format_tx_out(ConwayFormatTxOut {
            address: addr,
            amount: Value::new(ada, ma),
            datum_option: None,
            script_reference: None,
            encodings: None,
        })
    }
}
